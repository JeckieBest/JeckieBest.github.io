{"meta":{"title":"Jeckie","subtitle":"Jeckieの博客","description":"本科 | 物联网工程 | 后端 | 算法","author":"Jeckie","url":"http://blog.Jeckie.top","root":"/"},"pages":[{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-13T14:17:49.417Z","comments":true,"path":"categories/index.html","permalink":"http://blog.jeckie.top/categories/index.html","excerpt":"","text":""},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-11-13T14:17:49.292Z","comments":true,"path":"404.html","permalink":"http://blog.jeckie.top/404.html","excerpt":"","text":""},{"title":"","date":"2021-11-13T14:17:49.417Z","updated":"2021-11-13T14:17:49.417Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"http://blog.jeckie.top/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-13T14:17:49.417Z","comments":true,"path":"about/index.html","permalink":"http://blog.jeckie.top/about/index.html","excerpt":"","text":""},{"title":"","date":"2021-11-13T14:17:49.417Z","updated":"2021-11-13T14:17:49.417Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"http://blog.jeckie.top/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-11-13T14:17:49.307Z","comments":true,"path":"List/index.html","permalink":"http://blog.jeckie.top/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-13T14:17:49.417Z","comments":true,"path":"census/index.html","permalink":"http://blog.jeckie.top/census/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-11-13T14:17:49.417Z","comments":true,"path":"friends/index.html","permalink":"http://blog.jeckie.top/friends/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-13T14:17:49.417Z","comments":true,"path":"archives/index.html","permalink":"http://blog.jeckie.top/archives/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-11-14T03:23:25.470Z","comments":true,"path":"contact/index.html","permalink":"http://blog.jeckie.top/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Jeckieの友链信息 博客名称: Jeckieの博客 博客网址: 博客头像: https://img0.baidu.com/it/u=2919170279,884262835&amp;fm=26&amp;fmt=auto 博客介绍: 青春就是追逐自我，多数人青葱岁月，被优厚工作、稳定生活锁住。从没为自己活过的人，谈何青春？当你太顺从生活，它就会瞧不起你。青春不过是肆意张狂的那几年：宁有过错，不要错过。"},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-13T14:17:49.417Z","comments":true,"path":"resource/index.html","permalink":"http://blog.jeckie.top/resource/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-11-14T05:41:03.696Z","updated":"2021-11-13T14:17:49.292Z","comments":true,"path":"List/galleries/index.html","permalink":"http://blog.jeckie.top/List/galleries/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-13T14:17:49.417Z","comments":true,"path":"tags/index.html","permalink":"http://blog.jeckie.top/tags/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-11-13T14:17:49.307Z","comments":true,"path":"List/movies/index.html","permalink":"http://blog.jeckie.top/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-13T14:17:49.307Z","comments":true,"path":"List/tools/index.html","permalink":"http://blog.jeckie.top/List/tools/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-11-13T14:17:49.307Z","comments":true,"path":"List/music/index.html","permalink":"http://blog.jeckie.top/List/music/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-11-13T14:17:49.292Z","updated":"2021-11-13T14:17:49.292Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://blog.jeckie.top/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-11-13T14:17:49.292Z","updated":"2021-11-13T14:17:49.292Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://blog.jeckie.top/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-11-13T14:17:49.292Z","updated":"2021-11-13T14:17:49.292Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://blog.jeckie.top/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-11-13T14:17:49.292Z","updated":"2021-11-13T14:17:49.292Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://blog.jeckie.top/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-11-13T14:17:49.292Z","updated":"2021-11-13T14:17:49.292Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://blog.jeckie.top/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-11-14T05:41:11.601Z","updated":"2021-11-13T14:17:49.292Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://blog.jeckie.top/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-11-13T14:17:49.307Z","updated":"2021-11-13T14:17:49.307Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://blog.jeckie.top/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-11-13T14:17:49.307Z","updated":"2021-11-13T14:17:49.307Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://blog.jeckie.top/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-11-13T14:17:49.307Z","updated":"2021-11-13T14:17:49.307Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://blog.jeckie.top/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-11-13T14:17:49.307Z","updated":"2021-11-13T14:17:49.307Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://blog.jeckie.top/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-11-13T14:17:49.307Z","updated":"2021-11-13T14:17:49.307Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://blog.jeckie.top/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-11-13T14:17:49.307Z","updated":"2021-11-13T14:17:49.307Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://blog.jeckie.top/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""}],"posts":[{"title":"背包问题（dp）","slug":"背包问题","date":"2022-01-04T02:22:28.000Z","updated":"2022-01-05T07:22:05.900Z","comments":true,"path":"posts/19yz26.html","link":"","permalink":"http://blog.jeckie.top/posts/19yz26.html","excerpt":"","text":"背包问题（dp）化零散为整体，使用f(i,j)表示一大类集合 化整为零，f(i,j)是由谁转化来的（如何得出） 01背包n个物品（每个物品只有一个），每个物品v体积，w价值，有m个背包，如何取价值最大化 分析：F[ i , j ] = max ( F [ i - 1 , j ] , F [ i - 1 , j - v] + w ) 该公式表示：F[ i , j ] 从前 i 个物品中选出了总体积为 j 的物品放入背包的最大价值和 ​ F [ i - 1 , j ] 表示不选第 i 个物品的最大价值 ​ F [ i - 1 , j - v ] + w (条件：j &gt;= v) 表示不选第 i 个物品的最大价值 模板求最大价值优化前12345678910111213141516171819#include &lt;iostream&gt;using namespace std;const int N = 1e3 + 10;int f[N][N];//用于表示F[i,j]int n, m;int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ){ int v, w; cin &gt;&gt; v &gt;&gt; w; for (int j = 1; j &lt;= m; j ++ ){ if(j - v &gt;= 0) f[i][j] = max(f[i - 1][j], f[i - 1][j - v] + w);//如果有容量，就取最大值 else f[i][j] = f[i - 1][j]; } } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;} 优化后1234567891011121314151617#include &lt;iostream&gt;using namespace std;const int N = 1e3 + 10;int f[N];int n, m;int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ){ int v, w; cin &gt;&gt; v &gt;&gt; w; for (int j = m; j &gt;= v; j -- ){ f[j] = max(f[j], f[j - v] + w);//因为优化前只使用了i-1所以可以直接将二维数组转化为一维数组 } } cout &lt;&lt; f[m] &lt;&lt; endl; return 0;} 求方案数1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10010;int n, m;int f[N];//f[i,j]的含义是，前i个物品值为j的方案数int main(){ cin &gt;&gt; n &gt;&gt; m; f[0] = 1; for (int i = 0; i &lt; n; i ++ ) { int v; cin &gt;&gt; v; for (int j = m; j &gt;= v; j -- ) f[j] += f[j - v];//max函数变成了+发 } cout &lt;&lt; f[m] &lt;&lt; endl; return 0;} 完全背包问题n个物品（每个物品无限个），每个物品v体积，w价值，有m个背包，如何取价值最大化 分析F[ i , j ] = max ( F [ i - 1 , j ] , F [ i , j - v] + w ) 该公式表示：F[ i , j ] 从前 i 个物品中选出了总体积为 j 的物品放入背包的最大价值和 ​ F [ i - 1 , j ] 表示未选第 i 个物品的最大价值 ​ F [ i , j - v ] + w (条件：j &gt;= v) 表示选第 i 个物品的最大价值（选1，2，3……个的总和） 模板求最大价值优化前12345678910111213141516171819#include &lt;iostream&gt;using namespace std;const int N = 1010;int f[N][N];int n, m;int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ){ int v, w; scanf(\"%d%d\", &amp;v, &amp;w); for (int j = 1; j &lt;= m; j ++ ){ for (int k = 0; k * v &lt;= j; k ++ ){ f[i][j] = max(f[i][j], f[i - 1][j - v * k] + w * k); } } } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;} 优化后12345678910111213141516#include &lt;iostream&gt;using namespace std;const int N = 1010;int n, m;int f[N];int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ){ int v, w; cin &gt;&gt; v &gt;&gt; w; for (int j = v; j &lt;= m; j ++ )//注意和01背包的区别 f[j] = max(f[j - v] + w, f[j]); } cout &lt;&lt; f[m] &lt;&lt; endl; return 0;} 求方案数123456789101112131415161718#include &lt;iostream&gt;using namespace std;const int N = 1010;int n;int v[4] = {10, 20, 50, 100};//与01背包求方案数类似int f[N];int main(){ cin &gt;&gt; n; f[0] = 1; for (int i = 0; i &lt; 4; i ++ ) for (int j = v[i]; j &lt;= n; j ++ ) f[j] += f[j - v[i]]; cout &lt;&lt; f[n] &lt;&lt; endl; return 0;} 多重背包问题n个物品（每个物品有限个），每个物品v体积，w价值，有m个背包，如何取价值最大化 分组背包问题n个物品（每个物品有限个），有很多组，每个组只能取一个，每个物品v体积，w价值，有m个背包，如何取价值最大化 可将每个组看成一个01背包问题，此时就将分组背包转化为多个01背包问题、 背包问题练习题二维01背包12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;const int N = 110;int n, V, M;int f[N][N];int main(){ cin &gt;&gt; n &gt;&gt; V &gt;&gt; M; for (int i = 0; i &lt; n; i ++ ){ int v, m, w; cin &gt;&gt; v &gt;&gt; m &gt;&gt; w; for (int j = V; j &gt;= v; j -- ) for (int k = M; k &gt;= m; k -- )//注意，k循环可以反着写，也可以正着写，不影响。 f[j][k] = max(f[j][k], f[j - v][k - m] + w); } cout &lt;&lt; f[V][M] &lt;&lt; endl; return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172第四题暴力搜索#include &lt;iostream&gt;using namespace std;const int N = 20;int w[N][N];int path[N];int r_path[100][N];int res;int n, m;int cnt;void dfs(int u, int s, int v){ if (v &gt; m) { return ; } if (u == n + 1) { if (res &lt; s) { cnt = 0; memcpy(r_path[cnt ++ ], path, sizeof path); res = s; } else if (res == s) { memcpy(r_path[cnt ++ ], path, sizeof path); } return ; } for (int i = 1; i &lt;= n + 1; i ++ ) { path[u] = i - 1; dfs(u + 1, s, v); s -= w[u][i - 1], v -= i - 1; s += w[u][i], v += i; }}int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) cin &gt;&gt; w[i][j]; dfs(1, 0, 0); cout &lt;&lt; res &lt;&lt; endl;// cout &lt;&lt; cnt &lt;&lt; endl; for (int i = 0; i &lt; cnt; i ++ ) { for (int j = 1; j &lt;= n; j ++ ) cout &lt;&lt; j &lt;&lt; ' ' &lt;&lt; r_path[i][j] &lt;&lt; endl; puts(\"\"); } return 0;}","categories":[{"name":"算法篇","slug":"算法篇","permalink":"http://blog.jeckie.top/categories/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.jeckie.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://blog.jeckie.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Jeckie"},{"title":"离散化","slug":"离散化","date":"2022-01-03T11:19:59.000Z","updated":"2022-01-04T08:37:49.978Z","comments":true,"path":"posts/16fd92ae.html","link":"","permalink":"http://blog.jeckie.top/posts/16fd92ae.html","excerpt":"","text":"离散化思想离散化，就是当我们只关心数据的大小关系时，用排名代替原数据进行处理的一种预处理方法。离散化本质上是一种哈希，是一种映射，它在保持原序列大小关系的前提下把其映射成正整数。 当原数据很大或含有负数、小数时，难以表示为数组下标，一些算法和数据结构（如BIT）无法运作，这时我们就可以考虑将其离散化。 主要功能离散化主要是通过建立一个映射，将分散的元素的位置映射成连续的位置以节约空间。 例题例题一（离散化+前缀和）假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。 现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。 接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r][l,r] 之间的所有数的和。 输入格式第一行包含两个整数 n 和 m。 接下来 n 行，每行包含两个整数 x 和 c。 再接下来 m 行，每行包含两个整数 l 和 r。 输出格式共 m 行，每行输出一个询问中所求的区间内数字和。 数据范围-10^9 ≤ x ≤ 10^9 -10^5 ≤ n , m ≤ 10^5 -10^9 ≤ l ≤ r ≤ 10^9 -1000 ≤ c ≤ 10000 输入样例12345673 31 23 67 51 34 67 8 输出样例123805 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;/** * 由分析可知，本体若直接暴力，数据范围太大（2e9）,特别占用空间，因此使用离散化的思想，只对输入的位置进行操作，并通过PII * 类型的变量将值与位置存储起来，之后去重，排序，求前缀和即可得到结果 */using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 3e5 + 10;//之所以是3e5，是因为在最极端的情况下，n次操作与m次询问的l和r都是不同的，因此为3e5int n, m;int a[N], s[N];//用于求前缀和的数组vector&lt;int&gt; alls;vector&lt;PII&gt; add, query;int find(int x)//使用二分查找区间的位置，因为是有序的，时间复杂度为log2 N{ int l = 0; int r = alls.size() - 1; while (l &lt; r){ int mid = l + r &gt;&gt; 1; if(alls[mid] &gt;= x) r = mid; else l = mid + 1; } return l + 1;}int unique(vector&lt;int&gt; &amp;a){ int j = 0; for (int i = 0; i &lt; a.size(); i ++ ){ if(!i || a[i] != a[i - 1]){ a[j ++ ] = a[i]; } } return j;}int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++ ){ int x, c; cin &gt;&gt; x &gt;&gt; c; add.push_back({x, c}); alls.push_back(x); } for (int i = 0; i &lt; m; i ++ ){ int l, r; cin &gt;&gt; l &gt;&gt; r; query.push_back({l, r}); alls.push_back(l); alls.push_back(r); } sort(alls.begin(), alls.end()); alls.erase(alls.begin() + unique(alls), alls.end()); //erase删除函数，unique是去重函数（思想是将有重复的放入最后，删除即可得到去重后的函数） for (auto item : add){ int x = find(item.first); a[x] += item.second; } for (int i = 1; i &lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i];//处理前缀和数组 // 处理询问 for (auto item : query) { int l = find(item.first), r = find(item.second); cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl; } return 0;}","categories":[{"name":"算法篇","slug":"算法篇","permalink":"http://blog.jeckie.top/categories/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.jeckie.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"离散化","slug":"离散化","permalink":"http://blog.jeckie.top/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"}],"author":"Jeckie"},{"title":"递归算法","slug":"递归算法","date":"2021-11-23T12:25:30.000Z","updated":"2022-01-03T12:56:25.762Z","comments":true,"path":"posts/5f7017e8.html","link":"","permalink":"http://blog.jeckie.top/posts/5f7017e8.html","excerpt":"","text":"递归算法递归的基本概述：递归的定义：递归算法通过重复将问题分解为同类的子问题而解决问题的方法，个人认为递归的基本思想就是自己调用自己。需要注意的是使用递归时必须要有一个结束条件，也就是递归出口。 递归的优缺点：优点递归算法会使代码很简洁。 缺点 递归算法解题的运行效率较低。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出。 递归运行效率较低。所以一般不提倡用递归算法设计程序。 递归算法的**时间复杂度是O(n^2)**，所以也是比较暴力破解算法。 12345678function recursion(大规模){ if (end_condition){ // 明确的递归终止条件 end; // 简单情景 }else{ // 在将问题转换为子问题的每一步，解决该步中剩余部分的问题 solve; // 递去 recursion(小规模); // 递到最深处后，不断地归来 }} 例题斐波那契数列斐波那契数列如下： 1,1,2,3,5,8,13,21,34,… 1234567int fib(int n)//用到函数，使用函数时注意的形参和实参的区别{ if(n==1 || n==2)//确定前两个数，也是递归的出口 return 1; else return Fib(n-1)+Fib(n-2);//使用了递归，递归就是自己调用自己，是一种非常简便的写法} 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main(){ //斐波那契数列第一种解法，F(n)=F(n - 1)+F(n - 2) int n; cin&gt;&gt;n;//输入需要得到斐波那契数列的第几项 int a=1,b=1;,i=1;//a,b是数列的第一、二个值，i是用来判断第几项的数值 while(i&lt;n)//知道i大于n才结束循环，相当于求得第n项的值后结束 { int c=a+b;//c指下一项 a=b;//令第i项的第二个元素作为第i+1项的第一个元素，即n-2项 b=c;//将目前第i项的值作为i+1项的第二个元素，即n-1项 i++;//将i的值加一，保证循环可以退出，并且求第i+1项的数值 } cout&lt;&lt;a&lt;&lt;endl; return 0;} 第一种是递归方法，第二种是非递归方法。明显可以看出第一种比第二种代码更简洁，更精炼。然而效率却没有第二种高 杨辉三角123456789101112131415161718192021/** * Title: 杨辉三角形又称Pascal三角形，它的第i+1行是(a+b)i的展开式的系数。 * 它的一个重要性质是：三角形中的每个数字等于它两肩上的数字相加。 * * 例如，下面给出了杨辉三角形的前4行： * 1 * 1 1 * 1 2 1 * 1 3 3 1 */ public static int getValue(int x, int y) { if(y &lt;= x &amp;&amp; y &gt;= 0){ if(y == 0 || x == y){ // 递归终止条件 return 1; }else{ // 递归调用，缩小问题的规模 return getValue(x-1, y-1) + getValue(x-1, y); } } return -1; } 之后遇到递归类型的算法题目会更新，目前就讲解到这里。","categories":[{"name":"算法篇","slug":"算法篇","permalink":"http://blog.jeckie.top/categories/%E7%AE%97%E6%B3%95%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.jeckie.top/tags/%E7%AE%97%E6%B3%95/"}],"author":"Jeckie"},{"title":"hexo博客搭建","slug":"hexo博客搭建","date":"2021-11-15T11:19:59.000Z","updated":"2022-01-04T02:24:12.344Z","comments":true,"path":"posts/17fd91ae.html","link":"","permalink":"http://blog.jeckie.top/posts/17fd91ae.html","excerpt":"","text":"个人博客搭建预先配置这两个安装就不进行操作了，发两个试过水的安装教程。（本来想自己出的，结果安装的时候忘记截屏了。。。） 安装git: git安装配置 安装Node.js： Node.js安装配置 注意： git安装时公钥配置可选。 node最后检测时一定要以管理员身份运行，否则权限不够，不能下载。 附上最新版下载地址： git最新版下载地址 node最新版下载地址 安装Hexo并初步建立blog安装hexo打开cmd窗口，输入下方命令，下载Hexo（注意：一定要以管理员身份运行，之后所有操作，只要和下载相关都必须有管理员权限） npm install -g hexo-cli 建立博客进入放置博客的路径（用cd进入，d:**换盘），进入的路径就是你下载blog后的存放路径** 进入想要的路径后输入以下代码：hexo init blog创建blog，（blog是最后下载后的文件夹名，可以更改） 下载好后进入blog（文件夹路径）输入hexo s(博客会被启动，最后显示一个本地网址表示成功启动(http://localhost:4000)) 在cmd窗口摁CTRL+C可关闭博客。 现在只是一个框架有了，之后下载主题，并进行美化 更换主题我使用的是hexo-matery主题，不喜欢的小伙伴可以自己去GitHub上查询主题。 将主题下载到blog文件夹下的themes下 在cmd中使用git clone https://github.com/blinkfox/hexo-theme-matery.git 下载完成后，在根目录的__config.yml文件中找到themes将其切换成hexo-theme-matery 这样更换成功！！！ 文章 Front-matter 介绍新建文章 hexo new &lt;title&gt;。最后是文章标题，不需要加方括号 Front-matter 选项详解Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。 配置选项 默认值 描述 title Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项，且最好保证全局唯一 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 hide false 隐藏文章，如果hide值为true，则文章不会在首页显示 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 keywords 文章标题 文章关键字，SEO 时需要 reprintPolicy cc_by 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 注意: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图各有特色。 date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 Front-matter 示例。 最简示例1234---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00--- 最全示例123456789101112131415161718---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truehide: falsecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags: - Typora - Markdown--- 个人常用实例12345678910111213141516title: 题目date: 2021-11-15 19:19:59author: 作者名称coverImg: /medias/banner/6.jpgtop: falsecover: truetoc: truemathjax: falsesummary: 文章摘要tags: - 标签categories: - 分类abbrlink: 17fd92aereprintPolicy: cc_byimg: 图片路径 hexo clean &amp;&amp; hexo g -d更新操作 新建分类 categories 页categories 页是用来展示所有分类的页面，如果在你的博客 source 目录下还没有 categories/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"categories\" 编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容： 123456---title: categoriesdate: 2018-09-30 17:25:30type: \"categories\"layout: \"categories\"--- 新建标签 tags 页tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"tags\" 编辑你刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容： 123456---title: tagsdate: 2018-09-30 18:23:38type: \"tags\"layout: \"tags\"--- 新建关于我 about 页about 页是用来展示关于我和我的博客信息的页面，如果在你的博客 source 目录下还没有 about/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"about\" 编辑你刚刚新建的页面文件 /source/about/index.md，至少需要以下内容： 123456---title: aboutdate: 2018-09-30 17:25:30type: \"about\"layout: \"about\"--- 新建留言板 contact 页（可选的）contact 页是用来展示留言板信息的页面，如果在你的博客 source 目录下还没有 contact/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"contact\" 编辑你刚刚新建的页面文件 /source/contact/index.md，至少需要以下内容： 123456---title: contactdate: 2018-09-30 17:25:30type: \"contact\"layout: \"contact\"--- 注：本留言板功能依赖于第三方评论系统，请激活你的评论系统才有效果。并且在主题的 _config.yml 文件中，第 19 至 21 行的“菜单”配置，取消关于留言板的注释即可。 新建友情链接 friends 页（可选的）friends 页是用来展示友情链接信息的页面，如果在你的博客 source 目录下还没有 friends/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"friends\" 编辑你刚刚新建的页面文件 /source/friends/index.md，至少需要以下内容： 123456---title: friendsdate: 2018-12-12 21:25:30type: \"friends\"layout: \"friends\"--- 同时，在你的博客 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示： 1234567[{ \"avatar\": 头像地址, \"name\": 名称, \"introduction\": 介绍, \"url\": \"博客地址\", \"title\": 标题}] 新建 404 页如果在你的博客 source 目录下还没有 404.md 文件，那么你就需要新建一个 1hexo new page 404 编辑你刚刚新建的页面文件 /source/404/index.md，至少需要以下内容： 1234567---title: 404date: 2018-09-30 17:25:30type: \"404\"layout: \"404\"description: \"Oops～，我崩溃了！找不到你想要的页面 :(\"--- 代码高亮从 Hexo5.0 版本开始自带了 prismjs 代码语法高亮的支持，本主题对此进行了改造支持。 如果你的博客中曾经安装过 hexo-prism-plugin 的插件，那么你须要执行 npm uninstall hexo-prism-plugin 来卸载掉它，否则生成的代码中会有 { 和 } 的转义字符。 然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并将 prismjs.enable 的值设置为 true，主要配置如下： 123456789101112highlight: enable: false line_number: true auto_detect: false tab_replace: '' wrap: true hljs: falseprismjs: enable: true preprocess: true line_number: true tab_replace: '' 主题中默认的 prismjs 主题是 Tomorrow Night，如果你想定制自己的主题，可以前往 prismjs 下载页面 定制下载自己喜欢的主题 css 文件，然后将此 css 主题文件取名为 prism.css，替换掉 hexo-theme-matery 主题文件夹中的 source/libs/prism/prism.css 文件即可。 搜索本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下： 1npm install hexo-generator-search --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123search: path: search.xml field: post 中文链接转拼音（建议安装）如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。我们可以用 hexo-permalink-pinyin Hexo 插件使在生成文章时生成中文拼音的永久链接。 安装命令如下： 1npm i hexo-permalink-pinyin --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123permalink_pinyin: enable: true separator: '-' # default: '-' 注：除了此插件外，hexo-abbrlink 插件也可以生成非中文的链接。 文章字数统计插件（建议安装）如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。 安装命令如下： 1npm i --save hexo-wordcount 然后只需在本主题下的 _config.yml 文件中，将各个文章字数相关的配置激活即可： 1234567postInfo: date: true update: false wordCount: false # 设置文章字数统计为 true. totalCount: false # 设置站点文章总字数统计为 true. min2read: false # 阅读时长. readCount: false # 阅读次数. 添加emoji表情支持（可选的）本主题新增了对emoji表情的支持，使用到了 hexo-filter-github-emojis 的 Hexo 插件来支持 emoji表情的生成，把对应的markdown emoji语法（::,例如：:smile:）转变成会跳跃的emoji表情，安装命令如下： 1npm install hexo-filter-github-emojis --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123456githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后就可以在文章中对应位置看到你用emoji语法写的表情了。 添加Valine评论功能在主题的_config.yml文件中找到Valine，将enable中的false改成true，将appId和appKey改成自己应用的。 LeanCloud 注意：appId和appKey在LeanCloud上注册。注册完成后新建一个应用 成功后，如下图： 完成后打开设置的应用凭证–将appId和appKey填入配置文件。 修改社交链接在主题的配置文件（_config.yml）中找到socialLink，将对应的网址进行修改 修改打赏的二维码图片在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。 配置音乐播放器要支持音乐播放，在主题的 _config.yml 配置文件中激活music配置即可： 1234567891011121314151617# 是否在首页显示音乐music: enable: true title: # 非吸底模式有效 enable: true show: 听听音乐 server: netease # require music platform: netease, tencent, kugou, xiami, baidu type: playlist # require song, playlist, album, search, artist id: 503838841 # require song id / playlist id / album id / search keyword fixed: false # 开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: true # 列表默认折叠 1id`获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，`playlist`的`id即为这串数字。 修改主题颜色在主题文件的 /source/css/matery.css 文件中，搜索 .bg-color 来修改背景颜色： 123456789101112/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color { background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);}@-webkit-keyframes rainbow { /* 动态切换背景颜色. */}@keyframes rainbow { /* 动态切换背景颜色. */}","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://blog.jeckie.top/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.jeckie.top/tags/Hexo/"}],"author":"Jeckie"}],"categories":[{"name":"算法篇","slug":"算法篇","permalink":"http://blog.jeckie.top/categories/%E7%AE%97%E6%B3%95%E7%AF%87/"},{"name":"博客篇","slug":"博客篇","permalink":"http://blog.jeckie.top/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.jeckie.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://blog.jeckie.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"离散化","slug":"离散化","permalink":"http://blog.jeckie.top/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"Hexo","slug":"Hexo","permalink":"http://blog.jeckie.top/tags/Hexo/"}]}